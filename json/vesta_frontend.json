[{"Name":"coreutils","CurrentVersion":"8.32.0-4+b1","Type":"System","CVEID":"CVE-2024-0684","VulnerableVersion":"\u003c9.4","Level":"MEDIUM","PublishDate":"2024-02-06","Desc":"A flaw was found in the GNU coreutils \"split\" program. A heap overflow with user-controlled data of multiple hundred bytes in length could occur in the line_bytes_split() function, potentially leading to an application crash and denial of service.","Score":5.5},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2022-32221","VulnerableVersion":"\u003c7.86.0","Level":"CRITICAL","PublishDate":"2022-12-05","Desc":"When doing HTTP(S) transfers, libcurl might erroneously use the read callback (`CURLOPT_READFUNCTION`) to ask for data to send, even when the `CURLOPT_POSTFIELDS` option has been set, if the same handle previously was used to issue a `PUT` request which used that callback. This flaw may surprise the application and cause it to misbehave and either send off the wrong data or use memory after free or similar in the subsequent `POST` request. The problem exists in the logic for a reused handle when it is changed from a PUT to a POST.","Score":9.8},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2022-32207","VulnerableVersion":"\u003c7.84.0","Level":"CRITICAL","PublishDate":"2022-07-07","Desc":"When curl \u003c 7.84.0 saves cookies, alt-svc and hsts data to local files, it makes the operation atomic by finalizing the operation with a rename from a temporary name to the final target file name.In that rename operation, it might accidentally *widen* the permissions for the target file, leaving the updated file accessible to more users than intended.","Score":9.8},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2022-27778","VulnerableVersion":"\u003c7.83.0","Level":"HIGH","PublishDate":"2022-06-02","Desc":"A use of incorrectly resolved name vulnerability fixed in 7.83.1 might remove the wrong file when `--no-clobber` is used together with `--remove-on-error`.","Score":8.1},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2023-28319","VulnerableVersion":"\u003c8.1.0","Level":"HIGH","PublishDate":"2023-05-26","Desc":"A use after free vulnerability exists in curl \u003cv8.1.0 in the way libcurl offers a feature to verify an SSH server's public key using a SHA 256 hash. When this check fails, libcurl would free the memory for the fingerprint before it returns an error message containing the (now freed) hash. This flaw risks inserting sensitive heap-based data into the error message that might be shown to users or otherwise get leaked and revealed.","Score":7.5},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2023-27534","VulnerableVersion":"\u003c=7.88.1","Level":"HIGH","PublishDate":"2023-03-30","Desc":"A path traversal vulnerability exists in curl \u003c8.0.0 SFTP implementation causes the tilde (~) character to be wrongly replaced when used as a prefix in the first path element, in addition to its intended use as the first element to indicate a path relative to the user's home directory. Attackers can exploit this flaw to bypass filtering or execute arbitrary code by crafting a path like /~2/foo while accessing a server with a specific user.","Score":8.8},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2023-27533","VulnerableVersion":"\u003c=7.881","Level":"HIGH","PublishDate":"2023-03-30","Desc":"A vulnerability in input validation exists in curl \u003c8.0 during communication using the TELNET protocol may allow an attacker to pass on maliciously crafted user name and \"telnet options\" during server negotiation. The lack of proper input scrubbing allows an attacker to send content or perform option negotiation without the application's intent. This vulnerability could be exploited if an application allows user input, thereby enabling attackers to execute arbitrary code on the system.","Score":8.8},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2021-22926","VulnerableVersion":"\u003c7.78.0","Level":"HIGH","PublishDate":"2021-08-05","Desc":"libcurl-using applications can ask for a specific client certificate to be used in a transfer. This is done with the `CURLOPT_SSLCERT` option (`--cert` with the command line tool).When libcurl is built to use the macOS native TLS library Secure Transport, an application can ask for the client certificate by name or with a file name - using the same option. If the name exists as a file, it will be used instead of by name.If the appliction runs with a current working directory that is writable by other users (like `/tmp`), a malicious user can create a file name with the same name as the app wants to use by name, and thereby trick the application to use the file based cert instead of the one referred to by name making libcurl send the wrong client certificate in the TLS connection handshake.","Score":7.5},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2021-22946","VulnerableVersion":"\u003c7.79.0","Level":"HIGH","PublishDate":"2021-09-29","Desc":"A user can tell curl \u003e= 7.20.0 and \u003c= 7.78.0 to require a successful upgrade to TLS when speaking to an IMAP, POP3 or FTP server (`--ssl-reqd` on the command line or`CURLOPT_USE_SSL` set to `CURLUSESSL_CONTROL` or `CURLUSESSL_ALL` withlibcurl). This requirement could be bypassed if the server would return a properly crafted but perfectly legitimate response.This flaw would then make curl silently continue its operations **withoutTLS** contrary to the instructions and expectations, exposing possibly sensitive data in clear text over the network.","Score":7.5},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2022-22576","VulnerableVersion":"\u003c7.83.0","Level":"HIGH","PublishDate":"2022-05-26","Desc":"An improper authentication vulnerability exists in curl 7.33.0 to and including 7.82.0 which might allow reuse OAUTH2-authenticated connections without properly making sure that the connection was authenticated with the same credentials as set for this transfer. This affects SASL-enabled protocols: SMPTP(S), IMAP(S), POP3(S) and LDAP(S) (openldap only).","Score":8.1},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2022-27782","VulnerableVersion":"\u003c7.83.1","Level":"HIGH","PublishDate":"2022-06-02","Desc":"libcurl would reuse a previously created connection even when a TLS or SSHrelated option had been changed that should have prohibited reuse.libcurl keeps previously used connections in a connection pool for subsequenttransfers to reuse if one of them matches the setup. However, several TLS andSSH settings were left out from the configuration match checks, making themmatch too easily.","Score":7.5},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2022-27775","VulnerableVersion":"\u003c=7.82.0","Level":"HIGH","PublishDate":"2022-06-02","Desc":"An information disclosure vulnerability exists in curl 7.65.0 to 7.82.0 are vulnerable that by using an IPv6 address that was in the connection pool but with a different zone id it could reuse a connection instead.","Score":7.5},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2022-27781","VulnerableVersion":"\u003c7.83.1","Level":"HIGH","PublishDate":"2022-06-02","Desc":"libcurl provides the `CURLOPT_CERTINFO` option to allow applications torequest details to be returned about a server's certificate chain.Due to an erroneous function, a malicious server could make libcurl built withNSS get stuck in a never-ending busy-loop when trying to retrieve thatinformation.","Score":7.5},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2021-22947","VulnerableVersion":"\u003c7.79.0","Level":"MEDIUM","PublishDate":"2021-09-29","Desc":"When curl \u003e= 7.20.0 and \u003c= 7.78.0 connects to an IMAP or POP3 server to retrieve data using STARTTLS to upgrade to TLS security, the server can respond and send back multiple responses at once that curl caches. curl would then upgrade to TLS but not flush the in-queue of cached responses but instead continue using and trustingthe responses it got *before* the TLS handshake as if they were authenticated.Using this flaw, it allows a Man-In-The-Middle attacker to first inject the fake responses, then pass-through the TLS traffic from the legitimate server and trick curl into sending data back to the user thinking the attacker's injected data comes from the TLS-protected server.","Score":5.9},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2022-43552","VulnerableVersion":"\u003c7.87.0","Level":"MEDIUM","PublishDate":"2023-02-09","Desc":"A use after free vulnerability exists in curl \u003c7.87.0. Curl can be asked to *tunnel* virtually all protocols it supports through an HTTP proxy. HTTP proxies can (and often do) deny such tunnel operations. When getting denied to tunnel the specific protocols SMB or TELNET, curl would use a heap-allocated struct after it had been freed, in its transfer shutdown code path.","Score":5.9},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2022-27774","VulnerableVersion":"\u003c=7.82.0","Level":"MEDIUM","PublishDate":"2022-06-02","Desc":"An insufficiently protected credentials vulnerability exists in curl 4.9 to and include curl 7.82.0 are affected that could allow an attacker to extract credentials when follows HTTP(S) redirects is used with authentication could leak credentials to other services that exist on different protocols or port numbers.","Score":5.7},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2022-32205","VulnerableVersion":"\u003c7.84.0","Level":"MEDIUM","PublishDate":"2022-07-07","Desc":"A malicious server can serve excessive amounts of `Set-Cookie:` headers in a HTTP response to curl and curl \u003c 7.84.0 stores all of them. A sufficiently large amount of (big) cookies make subsequent HTTP requests to this, or other servers to which the cookies match, create requests that become larger than the threshold that curl uses internally to avoid sending crazy large requests (1048576 bytes) and instead returns an error.This denial state might remain for as long as the same cookies are kept, match and haven't expired. Due to cookie matching rules, a server on `foo.example.com` can set cookies that also would match for `bar.example.com`, making it it possible for a \"sister server\" to effectively cause a denial of service for a sibling site on the same second level domain using this method.","Score":4.3},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2022-32206","VulnerableVersion":"\u003c7.84.0","Level":"MEDIUM","PublishDate":"2022-07-07","Desc":"curl \u003c 7.84.0 supports \"chained\" HTTP compression algorithms, meaning that a serverresponse can be compressed multiple times and potentially with different algorithms. The number of acceptable \"links\" in this \"decompression chain\" was unbounded, allowing a malicious server to insert a virtually unlimited number of compression steps.The use of such a decompression chain could result in a \"malloc bomb\", makingcurl end up spending enormous amounts of allocated heap memory, or trying toand returning out of memory errors.","Score":6.5},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2021-22897","VulnerableVersion":"\u003c=7.76.1","Level":"MEDIUM","PublishDate":"2021-06-11","Desc":"curl 7.61.0 through 7.76.1 suffers from exposure of data element to wrong session due to a mistake in the code for CURLOPT_SSL_CIPHER_LIST when libcurl is built to use the Schannel TLS library. The selected cipher set was stored in a single \"static\" variable in the library, which has the surprising side-effect that if an application sets up multiple concurrent transfers, the last one that sets the ciphers will accidentally control the set used by all transfers. In a worst-case scenario, this weakens transport security significantly.","Score":5.3},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2022-32208","VulnerableVersion":"\u003c7.84.0","Level":"MEDIUM","PublishDate":"2022-07-07","Desc":"When curl \u003c 7.84.0 does FTP transfers secured by krb5, it handles message verification failures wrongly. This flaw makes it possible for a Man-In-The-Middle attack to go unnoticed and even allows it to inject data to the client.","Score":5.9},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2021-22925","VulnerableVersion":"\u003c7.78.0","Level":"MEDIUM","PublishDate":"2021-08-05","Desc":"curl supports the `-t` command line option, known as `CURLOPT_TELNETOPTIONS`in libcurl. This rarely used option is used to send variable=content pairs toTELNET servers.Due to flaw in the option parser for sending `NEW_ENV` variables, libcurlcould be made to pass on uninitialized data from a stack based buffer to theserver. Therefore potentially revealing sensitive internal information to theserver using a clear-text network protocol.This could happen because curl did not call and use sscanf() correctly whenparsing the string provided by the application.","Score":5.3},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2024-0853","VulnerableVersion":"\u003c8.5.0","Level":"MEDIUM","PublishDate":"2024-02-03","Desc":"curl inadvertently kept the SSL session ID for connections in its cache even when the verify status (*OCSP stapling*) test failed. A subsequent transfer to\nthe same hostname could then succeed if the session ID cache was still fresh, which then skipped the verify status check.","Score":5.3},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2022-27776","VulnerableVersion":"\u003c7.83.0","Level":"MEDIUM","PublishDate":"2022-06-02","Desc":"A insufficiently protected credentials vulnerability in fixed in curl 7.83.0 might leak authentication or cookie header data on HTTP redirects to the same host but another port number.","Score":6.5},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2023-23916","VulnerableVersion":"\u003c7.88.0","Level":"MEDIUM","PublishDate":"2023-02-23","Desc":"An allocation of resources without limits or throttling vulnerability exists in curl \u003cv7.88.0 based on the \"chained\" HTTP compression algorithms, meaning that a server response can be compressed multiple times and potentially with differentalgorithms. The number of acceptable \"links\" in this \"decompression chain\" wascapped, but the cap was implemented on a per-header basis allowing a maliciousserver to insert a virtually unlimited number of compression steps simply byusing many headers. The use of such a decompression chain could result in a \"malloc bomb\", making curl end up spending enormous amounts of allocated heap memory, or trying to and returning out of memory errors.","Score":6.5},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2021-22923","VulnerableVersion":"\u003c7.78.0","Level":"MEDIUM","PublishDate":"2021-08-05","Desc":"When curl is instructed to get content using the metalink feature, and a user name and password are used to download the metalink XML file, those same credentials are then subsequently passed on to each of the servers from which curl will download or try to download the contents from. Often contrary to the user's expectations and intentions and without telling the user it happened.","Score":5.3},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2021-22922","VulnerableVersion":"\u003c7.78.0","Level":"MEDIUM","PublishDate":"2021-08-05","Desc":"When curl is instructed to download content using the metalink feature, thecontents is verified against a hash provided in the metalink XML file.The metalink XML file points out to the client how to get the same contentfrom a set of different URLs, potentially hosted by different servers and theclient can then download the file from one or several of them. In a serial orparallel manner.If one of the servers hosting the contents has been breached and the contentsof the specific file on that server is replaced with a modified payload, curlshould detect this when the hash of the file mismatches after a completeddownload. It should remove the contents and instead try getting the contentsfrom another URL. This is not done, and instead such a hash mismatch is onlymentioned in text and the potentially malicious content is kept in the file ondisk.","Score":6.5},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2023-46218","VulnerableVersion":"\u003c=8.4.0","Level":"MEDIUM","PublishDate":"2023-12-07","Desc":"This flaw allows a malicious HTTP server to set \"super cookies\" in curl that\nare then passed back to more origins than what is otherwise allowed or\npossible. This allows a site to set cookies that then would get sent to\ndifferent and unrelated sites and domains.\n\nIt could do this by exploiting a mixed case flaw in curl's function that\nverifies a given cookie domain against the Public Suffix List (PSL). For\nexample a cookie could be set with `domain=co.UK` when the URL used a lower\ncase hostname `curl.co.uk`, even though `co.uk` is listed as a PSL domain.\n","Score":6.5},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2023-28320","VulnerableVersion":"\u003c8.1.0","Level":"MEDIUM","PublishDate":"2023-05-26","Desc":"A denial of service vulnerability exists in curl \u003cv8.1.0 in the way libcurl provides several different backends for resolving host names, selected at build time. If it is built to use the synchronous resolver, it allows name resolves to time-out slow operations using `alarm()` and `siglongjmp()`. When doing this, libcurl used a global buffer that was not mutex protected and a multi-threaded application might therefore crash or otherwise misbehave.","Score":5.9},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2023-28321","VulnerableVersion":"\u003c8.1.0","Level":"MEDIUM","PublishDate":"2023-05-26","Desc":"An improper certificate validation vulnerability exists in curl \u003cv8.1.0 in the way it supports matching of wildcard patterns when listed as \"Subject Alternative Name\" in TLS server certificates. curl can be built to use its own name matching function for TLS rather than one provided by a TLS library. This private wildcard matching function would match IDN (International Domain Name) hosts incorrectly and could as a result accept patterns that otherwise should mismatch. IDN hostnames are converted to puny code before used for certificate checks. Puny coded names always start with `xn--` and should not be allowed to pattern match, but the wildcard check in curl could still check for `x*`, which would match even though the IDN name most likely contained nothing even resembling an `x`.","Score":5.9},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2023-28322","VulnerableVersion":"\u003c8.1.0","Level":"LOW","PublishDate":"2023-05-26","Desc":"An information disclosure vulnerability exists in curl \u003cv8.1.0 when doing HTTP(S) transfers, libcurl might erroneously use the read callback (`CURLOPT_READFUNCTION`) to ask for data to send, even when the `CURLOPT_POSTFIELDS` option has been set, if the same handle previously wasused to issue a `PUT` request which used that callback. This flaw may surprise the application and cause it to misbehave and either send off the wrong data or use memory after free or similar in the second transfer. The problem exists in the logic for a reused handle when it is (expected to be) changed from a PUT to a POST.","Score":3.7},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2021-22898","VulnerableVersion":"\u003c=7.76.1","Level":"LOW","PublishDate":"2021-06-11","Desc":"curl 7.7 through 7.76.1 suffers from an information disclosure when the `-t` command line option, known as `CURLOPT_TELNETOPTIONS` in libcurl, is used to send variable=content pairs to TELNET servers. Due to a flaw in the option parser for sending NEW_ENV variables, libcurl could be made to pass on uninitialized data from a stack based buffer to the server, resulting in potentially revealing sensitive internal information to the server using a clear-text network protocol.","Score":3.1},{"Name":"curl","CurrentVersion":"7.74.0-1.3+deb11u1","Type":"System","CVEID":"CVE-2022-35252","VulnerableVersion":"\u003c7.85.0","Level":"LOW","PublishDate":"2022-09-23","Desc":"When curl is used to retrieve and parse cookies from a HTTP(S) server, itaccepts cookies using control codes that when later are sent back to a HTTPserver might make the server return 400 responses. Effectively allowing a\"sister site\" to deny service to all siblings.","Score":3.7},{"Name":"dpkg","CurrentVersion":"1.20.9","Type":"System","CVEID":"CVE-2022-1664","VulnerableVersion":"\u003c1.20.10","Level":"CRITICAL","PublishDate":"2022-05-26","Desc":"Dpkg::Source::Archive in dpkg, the Debian package management system, before version 1.21.8, 1.20.10, 1.19.8, 1.18.26 is prone to a directory traversal vulnerability. When extracting untrusted source packages in v2 and v3 source package formats that include a debian.tar, the in-place extraction can lead to directory traversal situations on specially crafted orig.tar and debian.tar tarballs.","Score":9.8},{"Name":"e2fsprogs","CurrentVersion":"1.46.2-2","Type":"System","CVEID":"CVE-2022-1304","VulnerableVersion":"\u003c1.46.5","Level":"HIGH","PublishDate":"2022-04-14","Desc":"An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.","Score":7.8},{"Name":"gzip","CurrentVersion":"1.10.0-4","Type":"System","CVEID":"CVE-2022-1271","VulnerableVersion":"\u003c1.12","Level":"HIGH","PublishDate":"2022-08-31","Desc":"An arbitrary file write vulnerability was found in GNU gzip's zgrep utility. When zgrep is applied on the attacker's chosen file name (for example, a crafted file name), this can overwrite an attacker's content to an arbitrary attacker-selected file. This flaw occurs due to insufficient validation when processing filenames with two or more newlines where selected content and the target file names are embedded in crafted multi-line file names. This flaw allows a remote, low privileged attacker to force zgrep to write arbitrary files on the system.","Score":8.8},{"Name":"libxml2","CurrentVersion":"2.9.10+dfsg-6.7","Type":"System","CVEID":"CVE-2022-40303","VulnerableVersion":"\u003c2.10.3","Level":"HIGH","PublishDate":"2022-11-23","Desc":"An issue was discovered in libxml2 before 2.10.3. When parsing a multi-gigabyte XML document with the XML_PARSE_HUGE parser option enabled, several integer counters can overflow. This results in an attempt to access an array at a negative 2GB offset, typically leading to a segmentation fault.","Score":7.5},{"Name":"libxml2","CurrentVersion":"2.9.10+dfsg-6.7","Type":"System","CVEID":"CVE-2021-3517","VulnerableVersion":"\u003c2.9.11","Level":"HIGH","PublishDate":"2021-05-19","Desc":"There is a flaw in the xml entity encoding functionality of libxml2 in versions before 2.9.11. An attacker who is able to supply a crafted file to be processed by an application linked with the affected functionality of libxml2 could trigger an out-of-bounds read. The most likely impact of this flaw is to application availability, with some potential impact to confidentiality and integrity if an attacker is able to use memory information to further exploit the application.","Score":8.6},{"Name":"libxml2","CurrentVersion":"2.9.10+dfsg-6.7","Type":"System","CVEID":"CVE-2021-3518","VulnerableVersion":"\u003c2.9.11","Level":"HIGH","PublishDate":"2021-05-18","Desc":"There's a flaw in libxml2 in versions before 2.9.11. An attacker who is able to submit a crafted file to be processed by an application linked with libxml2 could trigger a use-after-free. The greatest impact from this flaw is to confidentiality, integrity, and availability.","Score":8.8},{"Name":"libxml2","CurrentVersion":"2.9.10+dfsg-6.7","Type":"System","CVEID":"CVE-2024-25062","VulnerableVersion":"\u003c2.11.7","Level":"HIGH","PublishDate":"2024-02-04","Desc":"An issue was discovered in libxml2 before 2.11.7 and 2.12.x before 2.12.5. When using the XML Reader interface with DTD validation and XInclude expansion enabled, processing crafted XML documents can lead to an xmlValidatePopElement use-after-free.","Score":7.5},{"Name":"libxml2","CurrentVersion":"2.9.10+dfsg-6.7","Type":"System","CVEID":"CVE-2022-40304","VulnerableVersion":"\u003c2.10.3","Level":"HIGH","PublishDate":"2022-11-23","Desc":"An issue was discovered in libxml2 before 2.10.3. Certain invalid XML entity definitions can corrupt a hash table key, potentially leading to subsequent logic errors. In one case, a double-free can be provoked.","Score":7.8},{"Name":"libxml2","CurrentVersion":"2.9.10+dfsg-6.7","Type":"System","CVEID":"CVE-2022-23308","VulnerableVersion":"\u003c2.9.13","Level":"HIGH","PublishDate":"2022-02-26","Desc":"valid.c in libxml2 before 2.9.13 has a use-after-free of ID and IDREF attributes.","Score":7.5},{"Name":"libxml2","CurrentVersion":"2.9.10+dfsg-6.7","Type":"System","CVEID":"CVE-2022-29824","VulnerableVersion":"\u003c2.9.14","Level":"MEDIUM","PublishDate":"2022-05-03","Desc":"In libxml2 before 2.9.14, several buffer handling functions in buf.c (xmlBuf*) and tree.c (xmlBuffer*) don't check for integer overflows. This can result in out-of-bounds memory writes. Exploitation requires a victim to open a crafted, multi-gigabyte XML file. Other software using libxml2's buffer functions, for example libxslt through 1.1.35, is affected as well.","Score":6.5},{"Name":"libxml2","CurrentVersion":"2.9.10+dfsg-6.7","Type":"System","CVEID":"CVE-2016-3709","VulnerableVersion":"\u003c2.9.11","Level":"MEDIUM","PublishDate":"2022-07-28","Desc":"Possible cross-site scripting vulnerability in libxml after commit 960f0e2.","Score":6.1},{"Name":"libxml2","CurrentVersion":"2.9.10+dfsg-6.7","Type":"System","CVEID":"CVE-2021-3541","VulnerableVersion":"\u003c2.9.11","Level":"MEDIUM","PublishDate":"2021-07-09","Desc":"A flaw was found in libxml2. Exponential entity expansion attack its possible bypassing all existing protection mechanisms and leading to denial of service.","Score":6.5},{"Name":"libxml2","CurrentVersion":"2.9.10+dfsg-6.7","Type":"System","CVEID":"CVE-2023-28484","VulnerableVersion":"\u003c2.10.4","Level":"MEDIUM","PublishDate":"2023-04-24","Desc":"In libxml2 before 2.10.4, parsing of certain invalid XSD schemas can lead to a NULL pointer dereference and subsequently a segfault. This occurs in xmlSchemaFixupComplexType in xmlschemas.c.","Score":6.5},{"Name":"libxml2","CurrentVersion":"2.9.10+dfsg-6.7","Type":"System","CVEID":"CVE-2023-29469","VulnerableVersion":"\u003c2.10.4","Level":"MEDIUM","PublishDate":"2023-04-24","Desc":"An issue was discovered in libxml2 before 2.10.4. When hashing empty dict strings in a crafted XML document, xmlDictComputeFastKey in dict.c can produce non-deterministic values, leading to various logic and memory errors, such as a double free. This behavior occurs because there is an attempt to use the first byte of an empty string, and any value is possible (not solely the '\\0' value).","Score":6.5},{"Name":"libxml2","CurrentVersion":"2.9.10+dfsg-6.7","Type":"System","CVEID":"CVE-2023-39615","VulnerableVersion":"\u003c2.11.0","Level":"MEDIUM","PublishDate":"2023-08-29","Desc":"Xmlsoft Libxml2 v2.11.0 was discovered to contain an out-of-bounds read via the xmlSAX2StartElement() function at /libxml2/SAX2.c. This vulnerability allows attackers to cause a Denial of Service (DoS) via supplying a crafted XML file. NOTE: the vendor's position is that the product does not support the legacy SAX1 interface with custom callbacks; there is a crash even without crafted input.","Score":6.5},{"Name":"libxml2","CurrentVersion":"2.9.10+dfsg-6.7","Type":"System","CVEID":"CVE-2023-45322","VulnerableVersion":"\u003c=2.11.5","Level":"MEDIUM","PublishDate":"2023-10-06","Desc":"libxml2 through 2.11.5 has a use-after-free that can only occur after a certain memory allocation fails. This occurs in xmlUnlinkNode in tree.c. NOTE: the vendor's position is \"I don't think these issues are critical enough to warrant a CVE ID ... because an attacker typically can't control when memory allocations fail.\"","Score":6.5},{"Name":"libxml2","CurrentVersion":"2.9.10+dfsg-6.7","Type":"System","CVEID":"CVE-2021-3537","VulnerableVersion":"\u003c2.9.11","Level":"MEDIUM","PublishDate":"2021-05-14","Desc":"A vulnerability found in libxml2 in versions before 2.9.11 shows that it did not propagate errors while parsing XML mixed content, causing a NULL dereference. If an untrusted XML document was parsed in recovery mode and post-validated, the flaw could be used to crash the application. The highest threat from this vulnerability is to system availability.","Score":5.9},{"Name":"openssl","CurrentVersion":"1.1.1-k-1+deb11u1","Type":"System","CVEID":"CVE-2022-2274","VulnerableVersion":"\u003c3.0.4","Level":"CRITICAL","PublishDate":"2022-07-01","Desc":"The OpenSSL 3.0.4 release introduced a serious bug in the RSA implementation for X86_64 CPUs supporting the AVX512IFMA instructions. This issue makes the RSA implementation with 2048 bit private keys incorrect on such machines and memory corruption will happen during the computation. As a consequence of the memory corruption an attacker may be able to trigger a remote code execution on the machine performing the computation. SSL/TLS servers or other servers using 2048 bit RSA private keys running on machines supporting AVX512IFMA instructions of the X86_64 architecture are affected by this issue.","Score":9.8},{"Name":"openssl","CurrentVersion":"1.1.1-k-1+deb11u1","Type":"System","CVEID":"CVE-2016-7798","VulnerableVersion":"\u003c2.0.0","Level":"HIGH","PublishDate":"2017-01-30","Desc":"The openssl gem for Ruby uses the same initialization vector (IV) in GCM Mode (aes-*-gcm) when the IV is set before the key, which makes it easier for context-dependent attackers to bypass the encryption protection mechanism.","Score":7.5},{"Name":"openssl","CurrentVersion":"1.1.1-k-1+deb11u1","Type":"System","CVEID":"CVE-2021-4044","VulnerableVersion":"\u003c3.0.0","Level":"HIGH","PublishDate":"2021-12-14","Desc":"Internally libssl in OpenSSL calls X509_verify_cert() on the client side to verify a certificate supplied by a server. That function may return a negative return value to indicate an internal error (for example out of memory). Such a negative return value is mishandled by OpenSSL and will cause an IO function (such as SSL_connect() or SSL_do_handshake()) to not indicate success and a subsequent call to SSL_get_error() to return the value SSL_ERROR_WANT_RETRY_VERIFY. This return value is only supposed to be returned by OpenSSL if the application has previously called SSL_CTX_set_cert_verify_callback(). Since most applications do not do this the SSL_ERROR_WANT_RETRY_VERIFY return value from SSL_get_error() will be totally unexpected and applications may not behave correctly as a result. The exact behaviour will depend on the application but it could result in crashes, infinite loops or other similar incorrect responses. This issue is made more serious in combination with a separate bug in OpenSSL 3.0 that will cause X509_verify_cert() to indicate an internal error when processing a certificate chain. This will occur where a certificate does not include the Subject Alternative Name extension but where a Certificate Authority has enforced name constraints. This issue can occur even with valid chains. By combining the two issues an attacker could induce incorrect, application dependent behaviour. Fixed in OpenSSL 3.0.1 (Affected 3.0.0).","Score":7.5},{"Name":"openssl","CurrentVersion":"1.1.1-k-1+deb11u1","Type":"System","CVEID":"CVE-2022-0778","VulnerableVersion":"\u003c1.1.1n","Level":"HIGH","PublishDate":"2022-03-15","Desc":"The BN_mod_sqrt() function, which computes a modular square root, contains a bug that can cause it to loop forever for non-prime moduli. Internally this function is used when parsing certificates that contain elliptic curve public keys in compressed form or explicit elliptic curve parameters with a base point encoded in compressed form. It is possible to trigger the infinite loop by crafting a certificate that has invalid explicit curve parameters. Since certificate parsing happens prior to verification of the certificate signature, any process that parses an externally supplied certificate may thus be subject to a denial of service attack. The infinite loop can also be reached when parsing crafted private keys as they can contain explicit elliptic curve parameters. Thus vulnerable situations include: - TLS clients consuming server certificates - TLS servers consuming client certificates - Hosting providers taking certificates or private keys from customers - Certificate authorities parsing certification requests from subscribers - Anything else which parses ASN.1 elliptic curve parameters Also any other applications that use the BN_mod_sqrt() where the attacker can control the parameter values are vulnerable to this DoS issue. In the OpenSSL 1.0.2 version the public key is not parsed during initial parsing of the certificate which makes it slightly harder to trigger the infinite loop. However any operation which requires the public key from the certificate will trigger the infinite loop. In particular the attacker can use a self-signed certificate to trigger the loop during verification of the certificate signature. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0. It was addressed in the releases of 1.1.1n and 3.0.2 on the 15th March 2022. Fixed in OpenSSL 3.0.2 (Affected 3.0.0,3.0.1). Fixed in OpenSSL 1.1.1n (Affected 1.1.1-1.1.1m). Fixed in OpenSSL 1.0.2zd (Affected 1.0.2-1.0.2zc).","Score":7.5},{"Name":"openssl","CurrentVersion":"1.1.1-k-1+deb11u1","Type":"System","CVEID":"CVE-2023-3817","VulnerableVersion":"\u003c1.1.1n","Level":"MEDIUM","PublishDate":"2023-07-31","Desc":"Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the \"-check\" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.","Score":5.3},{"Name":"openssl","CurrentVersion":"1.1.1-k-1+deb11u1","Type":"System","CVEID":"CVE-2023-3817","VulnerableVersion":"\u003c1.1.1m","Level":"MEDIUM","PublishDate":"2023-07-31","Desc":"Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the \"-check\" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.","Score":5.3},{"Name":"openssl","CurrentVersion":"1.1.1-k-1+deb11u1","Type":"System","CVEID":"CVE-2023-3446","VulnerableVersion":"\u003c3.1.0","Level":"MEDIUM","PublishDate":"2023-07-19","Desc":"Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. One of those\nchecks confirms that the modulus ('p' parameter) is not too large. Trying to use\na very large modulus is slow and OpenSSL will not normally use a modulus which\nis over 10,000 bits in length.\n\nHowever the DH_check() function checks numerous aspects of the key or parameters\nthat have been supplied. Some of those checks use the supplied modulus value\neven if it has already been found to be too large.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulernable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the '-check' option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.","Score":5.3},{"Name":"openssl","CurrentVersion":"1.1.1-k-1+deb11u1","Type":"System","CVEID":"CVE-2023-3817","VulnerableVersion":"\u003c1.1.1o","Level":"MEDIUM","PublishDate":"2023-07-31","Desc":"Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the \"-check\" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.","Score":5.3},{"Name":"openssl","CurrentVersion":"1.1.1-k-1+deb11u1","Type":"System","CVEID":"CVE-2023-3817","VulnerableVersion":"\u003c1.1.1p","Level":"MEDIUM","PublishDate":"2023-07-31","Desc":"Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the \"-check\" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.","Score":5.3},{"Name":"openssl","CurrentVersion":"1.1.1-k-1+deb11u1","Type":"System","CVEID":"CVE-2023-3817","VulnerableVersion":"\u003c1.1.1q","Level":"MEDIUM","PublishDate":"2023-07-31","Desc":"Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the \"-check\" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.","Score":5.3},{"Name":"openssl","CurrentVersion":"1.1.1-k-1+deb11u1","Type":"System","CVEID":"CVE-2023-3817","VulnerableVersion":"\u003c1.1.1r","Level":"MEDIUM","PublishDate":"2023-07-31","Desc":"Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the \"-check\" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.","Score":5.3},{"Name":"openssl","CurrentVersion":"1.1.1-k-1+deb11u1","Type":"System","CVEID":"CVE-2023-3817","VulnerableVersion":"\u003c1.1.1s","Level":"MEDIUM","PublishDate":"2023-07-31","Desc":"Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the \"-check\" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.","Score":5.3},{"Name":"openssl","CurrentVersion":"1.1.1-k-1+deb11u1","Type":"System","CVEID":"CVE-2023-3817","VulnerableVersion":"\u003c1.1.1t","Level":"MEDIUM","PublishDate":"2023-07-31","Desc":"Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the \"-check\" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.","Score":5.3},{"Name":"openssl","CurrentVersion":"1.1.1-k-1+deb11u1","Type":"System","CVEID":"CVE-2023-3817","VulnerableVersion":"\u003c1.1.1u","Level":"MEDIUM","PublishDate":"2023-07-31","Desc":"Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the \"-check\" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.","Score":5.3},{"Name":"openssl","CurrentVersion":"1.1.1-k-1+deb11u1","Type":"System","CVEID":"CVE-2024-0727","VulnerableVersion":"\u003c3.2.0","Level":"MEDIUM","PublishDate":"2024-01-26","Desc":"Issue summary: Processing a maliciously formatted PKCS12 file may lead OpenSSL\nto crash leading to a potential Denial of Service attack\n\nImpact summary: Applications loading files in the PKCS12 format from untrusted\nsources might terminate abruptly.\n\nA file in PKCS12 format can contain certificates and keys and may come from an\nuntrusted source. The PKCS12 specification allows certain fields to be NULL, but\nOpenSSL does not correctly check for this case. This can lead to a NULL pointer\ndereference that results in OpenSSL crashing. If an application processes PKCS12\nfiles from an untrusted source using the OpenSSL APIs then that application will\nbe vulnerable to this issue.\n\nOpenSSL APIs that are vulnerable to this are: PKCS12_parse(),\nPKCS12_unpack_p7data(), PKCS12_unpack_p7encdata(), PKCS12_unpack_authsafes()\nand PKCS12_newpass().\n\nWe have also fixed a similar issue in SMIME_write_PKCS7(). However since this\nfunction is related to writing data we do not consider it security significant.\n\nThe FIPS modules in 3.2, 3.1 and 3.0 are not affected by this issue.","Score":5.5},{"Name":"tar","CurrentVersion":"1.34.0+dfsg-1","Type":"System","CVEID":"CVE-2022-48303","VulnerableVersion":"\u003c=1.34","Level":"MEDIUM","PublishDate":"2023-01-30","Desc":"GNU Tar through 1.34 has a one-byte out-of-bounds read that results in use of uninitialized memory for a conditional jump. Exploitation to change the flow of control has not been demonstrated. The issue occurs in from_header in list.c via a V7 archive in which mtime has approximately 11 whitespace characters.","Score":5.5},{"Name":"util-linux","CurrentVersion":"2.36.1-8","Type":"System","CVEID":"CVE-2021-37600","VulnerableVersion":"\u003c=2.37.1","Level":"MEDIUM","PublishDate":"2021-07-30","Desc":"An integer overflow in util-linux through 2.37.1 can potentially cause a buffer overflow if an attacker were able to use system resources in a way that leads to a large number in the /proc/sysvipc/sem file. NOTE: this is unexploitable in GNU C Library environments, and possibly in all realistic environments.","Score":5.5},{"Name":"util-linux","CurrentVersion":"2.36.1-8","Type":"System","CVEID":"CVE-2021-3995","VulnerableVersion":"\u003c2.37.3","Level":"MEDIUM","PublishDate":"2022-08-23","Desc":"A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows an unprivileged local attacker to unmount FUSE filesystems that belong to certain other users who have a UID that is a prefix of the UID of the attacker in its string form. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.","Score":5.5},{"Name":"util-linux","CurrentVersion":"2.36.1-8","Type":"System","CVEID":"CVE-2021-3996","VulnerableVersion":"\u003c2.37.3","Level":"MEDIUM","PublishDate":"2022-08-23","Desc":"A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows a local user on a vulnerable system to unmount other users' filesystems that are either world-writable themselves (like /tmp) or mounted in a world-writable directory. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.","Score":5.5},{"Name":"util-linux","CurrentVersion":"2.36.1-8","Type":"System","CVEID":"CVE-2022-0563","VulnerableVersion":"\u003c2.37.4","Level":"MEDIUM","PublishDate":"2022-02-21","Desc":"A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.","Score":5.5}]